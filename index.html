<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Stardust: AI Music Command Center</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --rack-bg: #1a0000; /* Dark red/black for vintage feel */
            --panel-bg: #2a0000; /* Slightly lighter red/black */
            --accent-color: #ff0000; /* Primary red for highlights */
            --text-color: #e0e0e0; /* Light gray for readability */
            --border-color: #440000; /* Darker red for borders */
            --control-bg: #550000; /* Red for controls */
            --input-bg: #0d0000; /* Very dark red for inputs */
            --font-mono: 'Roboto Mono', monospace;
            --font-pixel: 'Press Start 2P', cursive; /* Pixelated font for retro screens */
        }

        body {
            font-family: var(--font-mono);
            background-color: #0a0a0a;
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            box-sizing: border-box;
            overflow-x: hidden; /* Prevent horizontal scroll from animations */
        }

     .studio-rack {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            background-color: var(--rack-bg);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.3);
            position: relative;
            overflow: hidden; /* For space shuttle animation */
        }

     .panel {
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            box-shadow: inset 0 0 15px rgba(255, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

     .panel-header {
            font-family: var(--font-pixel);
            font-size: 1.3em;
            color: var(--accent-color);
            margin-bottom: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            text-shadow: 0 0 8px var(--accent-color);
        }

        /* Input Form Styling */
     .generation-form label {
            display: block;
            margin-bottom: 10px;
            color: var(--text-color);
            font-size: 0.95em;
        }

     .generation-form input[type="text"],
     .generation-form textarea,
     .generation-form select {
            width: calc(100% - 22px);
            padding: 12px;
            margin-bottom: 18px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            border-radius: 5px;
            font-family: var(--font-mono);
            font-size: 1em;
            box-shadow: inset 0 0 5px rgba(255, 0, 0, 0.1);
        }

     .generation-form textarea {
            resize: vertical;
            min-height: 100px;
        }

     .generation-form button {
            background-color: var(--accent-color);
            color: #000;
            border: none;
            padding: 14px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }

     .generation-form button:hover {
            background-color: #ff3333;
            transform: translateY(-3px);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
        }

        /* Vintage Red TV Screen */
     .crt-screen {
            background: linear-gradient(to top, #000000, #000000, #330000, #330000);
            background-size: 100% 1px;
            animation: scanlines infinite 55s linear;
            position: relative;
            overflow: hidden;
            border-radius: 20px; /* Rounded edges like old TVs */
            filter: blur(0.8px); /* Subtle blur for CRT effect */
            padding: 20px;
            box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.5), 0 0 30px rgba(255, 0, 0, 0.4);
            min-height: 300px;
            display: flex;
            flex-direction: column;
            font-family: var(--font-pixel);
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-color);
        }

     .crt-screen::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 0, 0, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px;
        }

     .crt-screen::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            z-index: 2;
            animation: flicker 0.15s infinite;
        }

        @keyframes scanlines {
            from { background-position: 0 0; }
            to { background-position: 0 -10px; }
        }

        @keyframes flicker {
            0% { opacity: 0.27861; }
            5% { opacity: 0.34769; }
            10% { opacity: 0.23604; }
            15% { opacity: 0.90626; }
            20% { opacity: 0.18128; }
            25% { opacity: 0.83891; }
            30% { opacity: 0.65583; }
            35% { opacity: 0.67807; }
            40% { opacity: 0.26559; }
            45% { opacity: 0.84693; }
            50% { opacity: 0.96019; }
            55% { opacity: 0.27861; } /* Ensure loop continuity */
            100% { opacity: 0.27861; }
        }

     .status-log {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
            font-size: 0.85em;
            line-height: 1.4;
            color: #ff6666; /* Lighter red for log entries */
        }

     .status-log div {
            margin-bottom: 5px;
        }

     .status-log.success { color: #00ff00; text-shadow: 0 0 5px #00ff00; } /* Green for success */
     .status-log.error { color: #ff0000; text-shadow: 0 0 8px #ff0000; animation: glitch-text 0.5s infinite; } /* Red for error with glitch */
     .status-log.info { color: #ffcc00; text-shadow: 0 0 5px #ffcc00; } /* Yellow for info */
     .status-log.pending { color: #00ffff; text-shadow: 0 0 5px #00ffff; } /* Cyan for pending */

        @keyframes glitch-text {
            0% { transform: translate(0); opacity: 1; }
            20% { transform: translate(-2px, 2px); opacity: 0.8; }
            40% { transform: translate(-2px, -2px); opacity: 1; }
            60% { transform: translate(2px, 2px); opacity: 0.8; }
            80% { transform: translate(2px, -2px); opacity: 1; }
            100% { transform: translate(0); opacity: 1; }
        }

        /* Red Matrix Control Screen */
     .matrix-control-screen {
            background-color: #0d0000; /* Dark background for matrix */
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: inset 0 0 15px rgba(255, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            min-height: 300px;
        }

     .matrix-control-screen canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

     .matrix-content {
            position: relative;
            z-index: 1;
            padding: 10px;
            font-family: var(--font-mono);
            color: #ff6666; /* Lighter red for matrix text */
            font-size: 0.9em;
            line-height: 1.5;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent overlay for readability */
            border-radius: 5px;
            height: calc(100% - 20px); /* Adjust for padding */
            overflow-y: auto;
        }

     .matrix-content div {
            margin-bottom: 5px;
        }

        /* Music Player & Archive */
     .audio-player-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

     .audio-player-container audio {
            width: 100%;
            background-color: var(--input-bg);
            border-radius: 5px;
            outline: none;
            box-shadow: inset 0 0 8px rgba(255, 0, 0, 0.1);
        }

     .custom-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }

     .custom-controls button,.track-play-button,.download-button {
            background-color: var(--control-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.2);
        }

     .custom-controls button:hover,.track-play-button:hover,.download-button:hover {
            background-color: #660000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
        }

     .track-list {
            margin-top: 25px;
            border-top: 2px solid var(--border-color);
            padding-top: 20px;
        }

     .track-list-item {
            display: grid;
            grid-template-columns: 80px 1fr auto auto; /* Cover, Title/Status, Play, Download */
            gap: 15px;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px dashed var(--border-color);
        }

     .track-list-item:last-child {
            border-bottom: none;
        }

     .track-cover {
            width: 80px;
            height: 80px;
            background-color: #333;
            border-radius: 5px;
            object-fit: cover;
            border: 1px solid var(--border-color);
        }

     .track-info {
            display: flex;
            flex-direction: column;
        }

     .track-title {
            color: var(--accent-color);
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

     .track-status {
            font-size: 0.85em;
            color: #00ffff; /* Cyan for status */
        }

     .track-status.complete { color: #00ff00; }
     .track-status.error { color: #ff0000; }

     .download-button {
            text-decoration: none;
            display: inline-block;
            padding: 8px 15px;
        }

        /* Space Shuttle Loading Animation */
     .space-shuttle-loader {
            position: fixed; /* Use fixed to cover entire viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95); /* Darker overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

     .space-shuttle-loader.active {
            opacity: 1;
            visibility: visible;
        }

     .shuttle-animation-container {
            width: 200px;
            height: 200px;
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }

     .shuttle-animation {
            width: 50px;
            height: 100px;
            background-color: #ccc;
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            animation: launch 3s forwards ease-out;
        }

     .shuttle-animation::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 0;
            width: 100%;
            height: 20px;
            background-color: #aaa;
            border-radius: 50% 50% 0 0;
        }

     .shuttle-animation::after {
            content: '';
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 40px;
            background-color: orange;
            border-radius: 50%;
            animation: exhaust 0.5s infinite alternate;
        }

        @keyframes launch {
            0% { bottom: 0; }
            100% { bottom: 150%; }
        }

        @keyframes exhaust {
            0% { transform: translateX(-50%) scaleY(1); opacity: 1; }
            100% { transform: translateX(-50%) scaleY(1.5); opacity: 0.7; }
        }

     .loader-text {
            color: var(--text-color);
            font-size: 1.2em;
            font-family: var(--font-pixel);
            text-shadow: 0 0 10px var(--accent-color);
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
         .studio-rack {
                grid-template-columns: 1fr 1fr;
            }
         .generation-panel {
                grid-column: span 1;
            }
         .player-panel {
                grid-column: span 1;
            }
         .crt-panel {
                grid-column: span 1;
            }
         .control-panel {
                grid-column: span 2; /* Full width for control panel on medium screens */
            }
        }

        @media (min-width: 1024px) {
         .studio-rack {
                grid-template-columns: 1fr 1fr 1fr; /* Three columns for larger screens */
            }
         .generation-panel {
                grid-column: span 1;
            }
         .player-panel {
                grid-column: span 1;
            }
         .crt-panel {
                grid-column: span 1;
            }
         .control-panel {
                grid-column: span 3; /* Full width for control panel on large screens */
            }
        }
    </style>
</head>
<body>
    <div class="studio-rack">
        <div class="panel generation-panel">
            <div class="panel-header">Générateur Musical AI</div>
            <form class="generation-form" id="musicGenerationForm">
                <label for="prompt">Prompt (Décrivez votre musique):</label>
                <textarea id="prompt" placeholder="Ex: 'Un morceau de piano calme et relaxant avec des mélodies douces, parfait pour la méditation.'" required></textarea>

                <label for="style">Style/Genre:</label>
                <input type="text" id="style" placeholder="Ex: 'Classique', 'Jazz', 'Pop', 'Electronic Dance'" required>

                <label for="vibe">Vibe/Ambiance:</label>
                <input type="text" id="vibe" placeholder="Ex: 'Énergique', 'Mélancolique', 'Paisible', 'Tendu'">

                <label for="title">Titre (Max 80 caractères):</label>
                <input type="text" id="title" maxlength="80" placeholder="Ex: 'Méditation au Coucher du Soleil'" required>

                <label for="model">Modèle AI:</label>
                <select id="model">
                    <option value="V4_5">V4.5 (Avancé, jusqu'à 8 min)</option>
                    <option value="V4">V4 (Haute Qualité, jusqu'à 4 min)</option>
                    <option value="V3_5">V3.5 (Équilibré, jusqu'à 4 min)</option>
                </select>

                <button type="submit">Générer Musique</button>
            </form>
        </div>

        <div class="panel crt-panel">
            <div class="panel-header">Moniteur de Requêtes</div>
            <div class="crt-screen">
                <div class="status-log" id="requestStatusLog">
                    <div>[00:00:00] Système en ligne. Attente des commandes...</div>
                </div>
            </div>
        </div>

        <div class="panel player-panel">
            <div class="panel-header">Lecture & Archive Musicale</div>
            <div class="audio-player-container">
                <audio id="audioPlayer" controls></audio>
                <div class="custom-controls">
                    <button id="playPauseBtn">Lecture / Pause</button>
                    <button id="stopBtn">Stop</button>
                    <button id="nextTrackBtn">Piste Suivante</button>
                </div>
            </div>

            <div class="track-list">
                <div class="panel-header" style="margin-top: 20px; border-top: none; padding-top: 0;">Pistes Générées</div>
                <div id="generatedTracksList">
                    </div>
            </div>
        </div>

        <div class="panel control-panel">
            <div class="panel-header">Console de Contrôle Backend</div>
            <canvas id="matrixCanvas"></canvas>
            <div class="matrix-content" id="backendStatusLog">
                <div>[00:00:00] Initialisation des modules backend...</div>
            </div>
        </div>
    </div>

    <div class="space-shuttle-loader" id="spaceShuttleLoader">
        <div class="shuttle-animation-container">
            <div class="shuttle-animation"></div>
        </div>
        <div class="loader-text" id="loaderText">Lancement de la génération...</div>
    </div>

    <script>
        // --- Éléments du DOM ---
        const musicGenerationForm = document.getElementById('musicGenerationForm');
        const audioPlayer = document.getElementById('audioPlayer');
        const generatedTracksList = document.getElementById('generatedTracksList');
        const requestStatusLog = document.getElementById('requestStatusLog');
        const backendStatusLog = document.getElementById('backendStatusLog');
        const spaceShuttleLoader = document.getElementById('spaceShuttleLoader');
        const loaderText = document.getElementById('loaderText');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const nextTrackBtn = document.getElementById('nextTrackBtn');

        let currentTrackIndex = 0;
        let tracks =; // Tableau pour stocker les données des pistes générées

        // --- Fonctions d'affichage des logs ---
        function logStatus(message, type = 'info', target = requestStatusLog) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            target.prepend(logEntry); // Ajouter en haut
            if (target.children.length > 50) { // Limiter le nombre de logs
                target.removeChild(target.lastChild);
            }
        }

        function logBackendStatus(message, type = 'info') {
            logStatus(message, type, backendStatusLog);
        }

        // --- Gestion de l'animation de la navette spatiale ---
        function showLoader(message) {
            loaderText.textContent = message;
            spaceShuttleLoader.classList.add('active');
            // Réinitialiser l'animation de la navette
            const shuttle = document.querySelector('.shuttle-animation');
            shuttle.style.animation = 'none';
            void shuttle.offsetWidth; // Trigger reflow
            shuttle.style.animation = null; // Restart animation
        }

        function hideLoader() {
            spaceShuttleLoader.classList.remove('active');
        }

        // --- Gestion du formulaire de génération ---
        musicGenerationForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const prompt = document.getElementById('prompt').value;
            const style = document.getElementById('style').value;
            const vibe = document.getElementById('vibe').value;
            const title = document.getElementById('title').value;
            const model = document.getElementById('model').value;

            logStatus('Requête de génération soumise...', 'info');
            showLoader('Lancement de la génération musicale...');

            try {
                // ********************************************************************
                // URL RÉELLE DE VOTRE FONCTION BACKEND BASE44 POUR generateMusic
                // Fournie par l'utilisateur: https://app--underground-studio-app-copy-9518db74.base44.app/api/apps/688deddde15fa30e9518db74/functions/generateMusic
                // ********************************************************************
                const response = await fetch('https://app--underground-studio-app-copy-9518db74.base44.app/api/apps/688deddde15fa30e9518db74/functions/generateMusic', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'api_key': 'f192ae5f2f6e419aa2314095abadbc65' // Votre clé API Base44 pour appeler la fonction
                    },
                    body: JSON.stringify({ prompt, style, vibe, title, model })
                });

                const data = await response.json();

                if (response.ok && data.taskId) {
                    logStatus(`Tâche de génération soumise: ${data.taskId}`, 'info');
                    logBackendStatus(`Backend a initié la tâche Suno: ${data.taskId}`, 'info');
                    startPolling(data.taskId); // Démarrer le polling pour le statut
                } else {
                    logStatus(`Échec de la soumission: ${data.message |

| 'Erreur inconnue.'}`, 'error');
                    logBackendStatus(`Échec de l'initialisation backend: ${data.message |

| 'Erreur inconnue.'}`, 'error');
                }
            } catch (error) {
                logStatus(`Erreur critique lors de la soumission: ${error.message}`, 'error');
                logBackendStatus(`Erreur critique backend: ${error.message}`, 'error');
            } finally {
                hideLoader();
            }

            // Réinitialiser le formulaire
            musicGenerationForm.reset();
        });

        // --- Polling pour le statut de la tâche ---
        let activePollingIntervals = {}; // Pour gérer les intervalles de polling par tâche

        async function startPolling(taskId) {
            let currentInterval = 2000; // 2 secondes initiales
            const maxInterval = 30000; // 30 secondes max
            const backoffMultiplier = 1.5;
            let retryCount = 0;
            const MAX_POLLING_RETRIES = 15; // Arrêter le polling après X tentatives

            const pollFunction = async () => {
                // ********************************************************************
                // URL RÉELLE DE VOTRE FONCTION BACKEND BASE44 POUR getMusicStatus
                // Cette URL suit le même format que generateMusic.
                // Exemple: 'https://app--underground-studio-app-copy-9518db74.base44.app/api/apps/688deddde15fa30e9518db74/functions/getMusicStatus?taskId=<taskId>'
                // ********************************************************************
                try {
                    const response = await fetch(`https://app--underground-studio-app-copy-9518db74.base44.app/api/apps/688deddde15fa30e9518db74/functions/getMusicStatus?taskId=${taskId}`, {
                        method: 'GET',
                        headers: {
                            'api_key': 'f192ae5f2f6e419aa2314095abadbc65' // Votre clé API Base44 pour appeler la fonction
                        }
                    });
                    const data = await response.json();

                    if (response.ok) {
                        updateFrontendStatus(taskId, data.status, data.musicData, data.errorMessage);
                        if (data.status === 'SUCCESS' |

| data.status.includes('FAILED')) {
                            clearInterval(activePollingIntervals[taskId]);
                            delete activePollingIntervals[taskId];
                            logBackendStatus(`Polling arrêté: Tâche ${taskId} terminée.`, 'info');
                        } else {
                            retryCount = 0; // Réinitialiser le compteur de réessais en cas de succès
                            currentInterval = Math.min(currentInterval * backoffMultiplier, maxInterval);
                            const jitter = Math.random() * 500; // Jitter aléatoire
                            activePollingIntervals[taskId] = setTimeout(pollFunction, currentInterval + jitter);
                        }
                    } else if (response.status === 429 |

| response.status === 430) { // Limite de débit Suno [1]
                        logStatus(`[${taskId}] Limite de débit atteinte. Réessai dans quelques instants.`, 'error');
                        logBackendStatus(`[${taskId}] Backend: Limite de débit Suno. Réessai automatique.`, 'error');
                        if (retryCount < MAX_POLLING_RETRIES) {
                            retryCount++;
                            currentInterval = Math.min(currentInterval * backoffMultiplier, maxInterval);
                            const jitter = Math.random() * 500;
                            activePollingIntervals[taskId] = setTimeout(pollFunction, currentInterval + jitter);
                        } else {
                            logStatus(`[${taskId}] Polling arrêté: Trop de tentatives.`, 'error');
                            logBackendStatus(`[${taskId}] Backend: Polling maximal atteint.`, 'error');
                            clearInterval(activePollingIntervals[taskId]);
                            delete activePollingIntervals[taskId];
                            updateFrontendStatus(taskId, 'FAILED', null, 'Polling maximal atteint.');
                        }
                    } else {
                        logStatus(`[${taskId}] Erreur lors de la récupération du statut: ${data.message |

| 'Erreur inconnue.'}`, 'error');
                        logBackendStatus(`[${taskId}] Backend: Erreur lors du polling: ${data.message |

| 'Erreur inconnue.'}`, 'error');
                        clearInterval(activePollingIntervals[taskId]);
                        delete activePollingIntervals[taskId];
                        updateFrontendStatus(taskId, 'FAILED', null, data.message |

| 'Erreur inconnue.');
                    }
                } catch (error) {
                    logStatus(`[${taskId}] Erreur réseau lors du polling: ${error.message}`, 'error');
                    logBackendStatus(`[${taskId}] Backend: Erreur réseau lors du polling: ${error.message}`, 'error');
                    clearInterval(activePollingIntervals[taskId]);
                    delete activePollingIntervals[taskId];
                    updateFrontendStatus(taskId, 'FAILED', null, error.message);
                }
            };

            activePollingIntervals[taskId] = setTimeout(pollFunction, currentInterval);
        }

        // --- Fonction de mise à jour du statut frontend (appelée par le polling) ---
        function updateFrontendStatus(taskId, status, musicData = null, errorMessage = null) {
            const timestamp = new Date().toLocaleTimeString();
            let message = `[${timestamp}] Tâche ${taskId}: `;
            let type = 'info';

            switch (status) {
                case 'PENDING':
                    message += 'En attente de traitement...';
                    type = 'pending';
                    break;
                case 'TEXT_SUCCESS':
                    message += 'Génération des paroles terminée.';
                    type = 'info';
                    break;
                case 'FIRST_SUCCESS':
                    message += 'Première piste musicale prête. Archivage en cours...';
                    type = 'info';
                    break;
                case 'SUCCESS':
                    message += 'Musique générée et archivée avec succès!';
                    type = 'success';
                    if (musicData && musicData.length > 0) {
                        musicData.forEach(song => {
                            addGeneratedSongToUI(song); // Ajoute les deux sons [1]
                        });
                    }
                    break;
                case 'RATE_LIMITED':
                    message += `Limite de débit atteinte. Réessai automatique.`;
                    type = 'error';
                    break;
                case 'SENSITIVE_WORD_ERROR':
                    message += `Contenu sensible détecté. Génération bloquée.`;
                    type = 'error';
                    break;
                case 'FAILED':
                    message += `Échec de la génération: ${errorMessage |

| 'Erreur inconnue.'}`;
                    type = 'error';
                    break;
                case 'ARCHIVING_FAILED':
                    message += `Échec de l'archivage: ${errorMessage |

| 'Erreur inconnue.'}`;
                    type = 'error';
                    break;
                default:
                    message += `Statut inconnu: ${status}`;
                    type = 'info';
            }
            logStatus(message, type);

            // Mettre à jour le statut spécifique de chaque son dans la liste si déjà ajouté
            if (musicData && musicData.length > 0) {
                musicData.forEach(song => {
                    const songStatusElement = document.getElementById(`status-${song.id}`);
                    if (songStatusElement) {
                        let songMessage = '';
                        let songTypeClass = '';
                        if (status === 'SUCCESS') {
                            songMessage = 'Statut: Prêt pour lecture';
                            songTypeClass = 'complete';
                        } else if (status.includes('FAILED') |

| status.includes('ERROR')) {
                            songMessage = 'Statut: Échec';
                            songTypeClass = 'error';
                        } else {
                            songMessage = `Statut: ${status}`;
                            songTypeClass = 'pending';
                        }
                        songStatusElement.textContent = songMessage;
                        songStatusElement.className = `track-status ${songTypeClass}`;
                    }
                });
            }
        }

        // --- Ajout des pistes générées à l'interface utilisateur ---
        function addGeneratedSongToUI(song) {
            const trackItem = document.createElement('div');
            trackItem.classList.add('track-list-item');
            trackItem.dataset.songId = song.id;
            trackItem.innerHTML = `
                <img src="${song.archived_image_url |

| song.image_url |
| 'https://via.placeholder.com/80?text=Cover'}" alt="Cover" class="track-cover">
                <div class="track-info">
                    <span class="track-title">${song.title |

| 'Titre Inconnu'}</span>
                    <span class="track-status" id="status-${song.id}">Statut: Reçu</span>
                    <small>Modèle: ${song.model_name |

| 'N/A'} | Durée: ${song.duration? Math.floor(song.duration / 60) + 'm ' + Math.round(song.duration % 60) + 's' : 'N/A'}</small>
                </div>
                <button class="track-play-button" data-audio-url="${song.stream_audio_url |

| ''}">Lecture</button>
                <a href="${song.archived_audio_url |

| song.audio_url |
| '#'}" download="${(song.title |
| 'generated_music').replace(/\s/g, '_')}.mp3" class="download-button">Télécharger MP3</a>
            `;
            generatedTracksList.prepend(trackItem); // Ajouter en haut de la liste

            tracks.unshift({ // Ajouter au début du tableau pour correspondre à l'affichage
                title: song.title,
                audioUrl: song.stream_audio_url,
                coverUrl: song.image_url,
                id: song.id,
                archivedAudioUrl: song.archived_audio_url,
                status: 'Reçu'
            });

            // Mettre à jour le statut en temps réel pour chaque son
            setTimeout(() => {
                const statusElem = document.getElementById(`status-${song.id}`);
                if (statusElem) statusElem.textContent = 'Statut: Lien transformé';
            }, 1000);
            setTimeout(() => {
                const statusElem = document.getElementById(`status-${song.id}`);
                if (statusElem) {
                    statusElem.textContent = 'Statut: Prêt pour lecture';
                    statusElem.classList.add('complete');
                }
            }, 2000);

            // Attacher l'écouteur d'événement au nouveau bouton de lecture
            trackItem.querySelector('.track-play-button').addEventListener('click', (event) => {
                const url = event.target.dataset.audioUrl;
                if (url) {
                    audioPlayer.src = url;
                    audioPlayer.play();
                    playPauseBtn.textContent = 'Pause';
                    logStatus(`Lecture de: "${song.title}"`, 'info');
                } else {
                    logStatus(`URL audio non disponible pour: "${song.title}"`, 'error');
                }
            });
        }

        // --- Contrôles du lecteur audio ---
        playPauseBtn.addEventListener('click', () => {
            if (audioPlayer.paused) {
                audioPlayer.play();
                playPauseBtn.textContent = 'Pause';
            } else {
                audioPlayer.pause();
                playPauseBtn.textContent = 'Lecture';
            }
        });

        stopBtn.addEventListener('click', () => {
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
            playPauseBtn.textContent = 'Lecture';
        });

        nextTrackBtn.addEventListener('click', () => {
            if (tracks.length > 0) {
                currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
                const nextSong = tracks;
                if (nextSong.audioUrl) {
                    audioPlayer.src = nextSong.audioUrl;
                    audioPlayer.play();
                    playPauseBtn.textContent = 'Pause';
                    logStatus(`Lecture de la piste suivante: "${nextSong.title}"`, 'info');
                } else {
                    logStatus(`URL audio non disponible pour la piste suivante.`, 'error');
                }
            } else {
                logStatus('Aucune piste disponible dans la bibliothèque.', 'info');
            }
        });

        audioPlayer.addEventListener('ended', () => {
            playPauseBtn.textContent = 'Lecture';
            // Optionnel: jouer la piste suivante automatiquement
            // nextTrackBtn.click();
        });

        // --- Effet Matrix sur Canvas ---
        const matrixCanvas = document.getElementById('matrixCanvas');
        const ctx = matrixCanvas.getContext('2d');

        let matrixWidth, matrixHeight;
        let columns;
        let drops =;
        const fontSize = 16;
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-={}|;:,.<>/?'; // Caractères de la matrice

        function initializeMatrix() {
            matrixWidth = matrixCanvas.width = matrixCanvas.offsetWidth;
            matrixHeight = matrixCanvas.height = matrixCanvas.offsetHeight;
            columns = Math.floor(matrixWidth / fontSize);
            drops =;
            for (let i = 0; i < columns; i++) {
                drops[i] = 1; // Chaque colonne commence en haut
            }
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Couleur de fond semi-transparente pour l'effet de traînée
            ctx.fillRect(0, 0, matrixWidth, matrixHeight);
        }

        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Traînée
            ctx.fillRect(0, 0, matrixWidth, matrixHeight);

            ctx.fillStyle = '#ff0000'; // Couleur rouge pour le texte de la matrice
            ctx.font = `${fontSize}px var(--font-mono)`;

            for (let i = 0; i < drops.length; i++) {
                const text = characters.charAt(Math.floor(Math.random() * characters.length));
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                if (drops[i] * fontSize > matrixHeight && Math.random() > 0.975) {
                    drops[i] = 0; // Réinitialiser la goutte en haut
                }
                drops[i]++;
            }
            requestAnimationFrame(drawMatrix);
        }

        // Initialisation et redimensionnement du canvas
        window.addEventListener('resize', initializeMatrix);
        initializeMatrix();
        drawMatrix();

        // Initialisation du lecteur avec une piste vide
        audioPlayer.src = '';
        audioPlayer.load();

        // Message de bienvenue initial
        logStatus('Bienvenue au Project Stardust. Prêt pour le lancement.', 'info');
        logBackendStatus('Systèmes de contrôle en ligne. Attente des commandes de génération.', 'info');

    </script>
</body>
</html>
